// In migrations/1_initial_schema.go
package migrations

import (
	"github.com/pocketbase/pocketbase/daos"
	m "github.com/pocketbase/pocketbase/migrations"
	"github.com/pocketbase/pocketbase/models"
	"github.com/pocketbase/pocketbase/models/schema"
	"github.com/pocketbase/pocketbase/tools/types"
)

// This migration is auto-generated by PocketBase when exporting from the Admin UI.
// You can also write them manually.
func init() {
	m.Register(func(db *daos.Dao) error {
		// --- CREATE `positions` COLLECTION ---
		positionsCollection := &models.Collection{
			Name:     "positions",
			Type:     models.CollectionTypeBase,
			ListRule: types.Pointer("@request.auth.id != ''"),
			ViewRule: types.Pointer("@request.auth.id != ''"),
			Schema: schema.NewSchema(
				&schema.SchemaField{
					Name:     "name",
					Type:     schema.FieldTypeText,
					Required: true,
					Options:  &schema.TextOptions{},
				},
			),
		}
		if err := db.SaveCollection(positionsCollection); err != nil {
			return err
		}

		// --- CREATE `scoring_formats` COLLECTION ---
		formatsCollection := &models.Collection{
			Name:     "scoring_formats",
			Type:     models.CollectionTypeBase,
			ListRule: types.Pointer("@request.auth.id != ''"),
			ViewRule: types.Pointer("@request.auth.id != ''"),
			Schema: schema.NewSchema(
				&schema.SchemaField{
					Name:     "name",
					Type:     schema.FieldTypeText,
					Required: true,
					Options:  &schema.TextOptions{},
				},
			),
		}
		if err := db.SaveCollection(formatsCollection); err != nil {
			return err
		}

		// --- CREATE `players` COLLECTION ---
		playersCollection := &models.Collection{
			Name:     "players",
			Type:     models.CollectionTypeBase,
			ListRule: types.Pointer("@request.auth.id != ''"),
			ViewRule: types.Pointer("@request.auth.id != ''"),
			Schema: schema.NewSchema(
				&schema.SchemaField{
					Name:     "name",
					Type:     schema.FieldTypeText,
					Required: true,
					Options:  &schema.TextOptions{},
				},
				&schema.SchemaField{
					Name:     "primary_position",
					Type:     schema.FieldTypeRelation,
					Required: true,
					Options: &schema.RelationOptions{
						CollectionId:  positionsCollection.Id,
						CascadeDelete: false,
						MaxSelect:     types.Pointer(1),
					},
				},
			),
		}
		if err := db.SaveCollection(playersCollection); err != nil {
			return err
		}

		// --- CREATE `weekly_rankings` COLLECTION ---
		rankingsCollection := &models.Collection{
			Name:     "weekly_rankings",
			Type:     models.CollectionTypeBase,
			ListRule: types.Pointer("@request.auth.id != ''"),
			ViewRule: types.Pointer("@request.auth.id != ''"),
			Schema: schema.NewSchema(
				&schema.SchemaField{
					Name:     "player",
					Type:     schema.FieldTypeRelation,
					Required: true,
					Options: &schema.RelationOptions{
						CollectionId:  playersCollection.Id,
						CascadeDelete: false,
						MaxSelect:     types.Pointer(1),
					},
				},
				&schema.SchemaField{
					Name:     "ranking_category",
					Type:     schema.FieldTypeRelation,
					Required: true,
					Options: &schema.RelationOptions{
						CollectionId:  positionsCollection.Id,
						CascadeDelete: false,
						MaxSelect:     types.Pointer(1),
					},
				},
				&schema.SchemaField{
					Name:     "format",
					Type:     schema.FieldTypeRelation,
					Required: true,
					Options: &schema.RelationOptions{
						CollectionId:  formatsCollection.Id,
						CascadeDelete: false,
						MaxSelect:     types.Pointer(1),
					},
				},
				&schema.SchemaField{
					Name:     "tier",
					Type:     schema.FieldTypeNumber,
					Required: true,
					Options:  &schema.NumberOptions{},
				},
				&schema.SchemaField{
					Name:     "week",
					Type:     schema.FieldTypeNumber,
					Required: true,
					Options:  &schema.NumberOptions{},
				},
				&schema.SchemaField{
					Name:     "year",
					Type:     schema.FieldTypeNumber,
					Required: true,
					Options:  &schema.NumberOptions{},
				},
			),
		}
		return db.SaveCollection(rankingsCollection)

	}, func(db *daos.Dao) error {
		// This is the "down" migration to roll back changes.
		// For this initial schema, we delete the collections in reverse order.
		tables := []string{
			"weekly_rankings",
			"players",
			"scoring_formats",
			"positions",
		}
		for _, name := range tables {
			if _, err := db.FindCollectionByNameOrId(name); err == nil {
				if err := db.DeleteCollection(name); err != nil {
					return err
				}
			}
		}
		return nil
	})
}
